# 백준을 위한 정수론

### 개요
알고리즘 문제를 풀기 위한 기초적인 정수론 지식을 다루는 것이 목표이다. 

어려운 내용보다는 기초적인 소수 판별, 소인수 분해, 최대 공약수에 초점을 맞추고자 한다.

수학 교재라면 예제 또는 연습 문제는 수학 문제 풀이 내지는 증명이 되겠지만, 여기서는 목적에 맞춰 코드 작성이 제시된다.

예제의 경우 특별한 조건이 없다면 시간 복잡도 등을 고려하지 말고 문제의 요구사항에만 충실하게 작성해 볼 것을 추천한다. 비효율적이더라도 코드를 작성해보아야 풀이와 비교하며 코드의 장단점과 개선점을 파악할 수 있기 때문이다.


### 목차
1. [소수](#1-소수)
   1. [소수 판별법](#11-소수-판별법)
   2. [소수 목록 구하기](#12-소수-목록-구하기)
   3. [소인수분해](#13-소인수-분해)
2. [최대 공약수](#2-최대-공약수)
   1. [최대 공약수를 구하는 방법](#21-최대-공약수를-구하는-방법)
   2. [오일러 피 함수](#23-오일러-피-함수)
   3. [페르마 소정리와 오일러 공식](#24-페르마-소정리와-오일러-공식)


# 1. 소수

## 1.1 소수 판별법

### 1.1.1 소수 판별법 1차시
주어진 숫자가 소수인지 아닌지 판별하는 방법을 알아보자.

> **Definition**
> 
> 소수란 1과 자기자신만을 약수로 가지는 숫자를 말한다.

정의에 따르면 주어진 숫자 N이 소수인지 아닌지는 단순하게 1 ~ N-1로 나누어보면 알 수 있다.

> **예제**
>
> 숫자 N을 입력 받으면 N이 소수인지 아닌지 판별하는 코드를 작성해보자.
> 
> 예제 풀이
> ```python
> N = int(input())
> for i in range(1,N):
>     if N%i == 0:
>         print('not prime')
>         break
> else:
>     print('prime')
> ```


#### --쉬는시간--
예제를 푸는 시간 동안 한 학생이 문제를 벌써 다 풀고 나서는 질문을 한다.

<span style="color: green">**아니 그런데 N/2까지만 나눠보고 안되면 그 뒤로는 나누어떨어질리가 없잖아요! 왜 N-1까지 나누는거에요?**</span>

![alt text](![image-1](https://github.com/user-attachments/assets/3e42824b-c934-42fb-88f4-01877f15c0e7)

맞는 말이다. 할 말이 없다. 하지만 강사의 체면을 내세우기 위해서 다음과 같이 맞받아치고 재빨리 넘어간다.



<span style="color: red">**N번의 연산을 해도, N/2번의 연산을 해도 시간 복잡도는 O(N)으로 동일하단다.**</span>

#### 연습문제

`문제1) 1978. 소수찾기 https://www.acmicpc.net/problem/1978`

-----------------------------------------------------------




### 1.1.2 소수 판별법 2차시

약수가 존재하지 않는 것이 확실한 구간을 굳이 탐색해서 N이 나눠지는지 확인하는 것은 비효율적이다. 하지만 그 구간의 시작점이 N/2일까? 더 앞에서 시작될 수도 있지 않을까?

> **Theorem**
>
> N의 약수를 정렬해서 늘어놓았을 때, N의 약수 d와 N/d는 대칭된 위치에 있다.

어떤 수를 약수로 나눈 결과 또한 약수임과 큰 수로 나눌수록 작은 수가 나온다는 것을 떠올리면 따로 증명하지 않아도 직관적으로 이해할 수 있다.

> **Corollary**
>
> N이 1 ~ d로 나누어지지 않는다면 N/d ~ N-1로도 나누어지지 않는다.

따라서 소수인지 확인하기 위해서는 루트N까지의 숫자만 확인해보면 된다. 시간 복잡도 역시 O(루트N)으로 줄어들게 된다.

> **예제**
>
> 새로 배운 내용을 활용하여 숫자 N을 입력 받으면 N이 소수인지 아닌지 판별하는 코드를 작성해보자.
> 
> 예제 풀이
> ```python
> N = int(input())
> for i in range(1,int(N**0.5)+1):
>     if N%i == 0:
>         print('not prime')
>         break
> else:
>     print('prime')
> ```



시간 복잡도 O(루트N)은 충분히 빠른 알고리즘이다. 파이썬은 1초에 약 2000만 정도의 작업을 한다. O(루트N) 알고리즘은 1조 정도의 숫자는 순식간에 판별할 수 있다. 하지만 이 방법은 많은 숫자에 대해서 판별을 하거나, 인접한 소수를 찾는 데에는 부적합하다. (왜?) 따라서 다음 시간에는 다른 방법을 알아볼 것이다.

#### 연습문제
`문제1) 1037. 약수 https://www.acmicpc.net/problem/1037`<br>
`문제2) 1978. 소수 찾기 https://www.acmicpc.net/problem/1978`

-----------------------------------------------------------




## 1.2 소수 목록 구하기

### 1.2.1 에라토스테네스의 체

주어진 숫자 이하의 모든 소수를 구하는 방법을 알아보자. 대표적으로 에라토스테네스의 체가 있다.

> **Theorem**
>
> 2 ~ N까지의 숫자를 적은 다음, 숫자를 차례대로 순회하다가 지워지지 않은 숫자를 만나면 해당 숫자의 배수를 모두 지우는 작업을 반복한다. 그러면 소수만 남게 된다.
> 
> 이러한 소수를 구하는 로직을 에라토스테네스의 체라고 한다.

지워진 숫자들은 전부 **어떤** 숫자의 배수이며, 남은 숫자들은 이전의 **모든** 숫자들에 대해서 배수가 아니므로 남아 있는 수는 전부 소수가 된다.

> **예제**
>
> 에라토스테네스의 체를 코드로 작성하여 N 이하의 수에 대해 소수여부를 판별하는 코드를 작성해보자.
> 
> 예제 풀이
> ```python
> N = int(input())
> is_prime = [True]*(N+1)
> is_prime[0] = is_prime[1] = False 
> for i in range(2,N+1):
>     if is_prime[i] == True:
>         for j in range(i+i,N+1,i):
>             is_prime[j] = False
> ```

에라토스테네스의 체의 시간 복잡도는 O(N log(logN))이라고 한다. 합성수는 자신의 소인수 개수만큼 중복해서 처리가 되기 때문에 O(N)이 되지 못한다. 이는 다소 비효율적이라는 생각이 들 수도 있다. 소수 2의 배수를 지우면서 6은 이미 지워졌는데 소수3을 처리할 때 다시 방문하는 것이 마음에 들지 않는다.

에라토스테네스의 체를 응용하여 N 이하의 소수를 O(N) 복잡도로 구하면서, 각 수의 가장 작은 소인수를 동시에 구하는 방법도 있다. 이는 이후 소인수분해 챕터에서 다루도록 하자.

#### --쉬는시간--
수업을 마치려는데 한 학생이 손을 듦과 동시에 다른 학생들의 탄식이 들린다.

<span style="color: green">**6이 이미 지워졌는데 또 처리하는게 문제라면 아래 코드처럼 조건문을 넣어서 처리를 안하면 되잖아요?**</span>

> ```python
> N = int(input())
> is_prime = [True]*(N+1)
> is_prime[0] = is_prime[1] = False 
> for i in range(2,N+1):
>     if is_prime[i] == True:
>         for j in range(i+i,N+1,i):
>             if is_prime[j] == True:
>                 is_prime[j] = False
> print(is_prime) # 소수 여부를 출력
> print([i for i in range(N+1) if is_prime[i]]) # 숫자를 출력
> ```
충분히 가질 수 있는 의문이라고 생각한다. 아니, 아주 좋은 질문일지도 모른다. 잠깐 뜸을 들이다 답을 해준다.

![alt text](https://github.com/user-attachments/assets/77b4ca9c-5f88-4090-8d22-f2d075757022)


<span style="color: red">**조건 판별 계산은 누가 할까?**</span>



#### 연습 문제
`문제1) 1456. 거의 소수 https://www.acmicpc.net/problem/1456`<br>
`문제2) 3896. 소수 사이 수열 https://www.acmicpc.net/problem/3896`<br>
`문제3) 1963. 소수 경로 https://www.acmicpc.net/problem/1963`




-----------------------------------------------------------

## 1.3 소인수 분해

### 1.3.1 소인수 분해 1차시

주어진 숫자를 소인수 분해하는 방법을 알아보자.

> **Definition**
> 
> 소인수 분해란 주어진 정수를 소수들의 곱으로 나타내는 것을 말한다. 
> 
> 소수의 순서를 오름차순으로 정렬한다면 그 표현 방식은 **유일하다.**



> **예제**
>
> 주어진 숫자를 입력 받아서 소인수 분해하는 코드를 작성해보자.
> 
> 예제 풀이
> ```python
> N = int(input())
> answer = [] # 소인수를 담을 리스트
> for i in range(2, int(N**0.5)+1):
>     if N%i == 0:
>         while N%i == 0:
>             answer.append(i)
>             N//=i
> if N>1:
>     answer.append(N)
> print(answer)
> ```

소인수분해는 주어진 숫자를 나누는 소수를 찾는 것이다. 그래서 일차적으로 소수 목록을 뽑아두어야한다고 생각할 수도 있다. 하지만 위의 코드를 보면 꼭 그렇지만은 않다. 


#### 연습 문제
`문제1) 11653. 소인수분해 https://www.acmicpc.net/problem/11653`



### 1.3.2 소인수 분해 2차시

이번엔 전처리를 통해 많은 숫자의 소인수 분해를 다뤄보자.

<U>**소수 목록이 미리 구해져있다고 가정한다면**</U> 2이상 루트N 이하의 소수만 확인해보면 되므로 더 효율적인 코드를 작성할 수 있다. 하지만 그것보다 조금 더 멋진 정보를 미리 제공한다면 어떨까?

1차시 예제 풀이의 코드에 36을 넣고 돌리면 N이 36 -> 18 -> 9 -> 3 -> 1로 변해가는 것을 확인할 수 있다. 여기서 약간의 힌트를 얻어보자.



> **Theorem**
>
> 소인수 분해는 최소 인수를 구하여 나누는 것을 반복한 결과와 같다.

소인수 분해 = 최소인수 \* (몫의 소인수 분해)이므로 자명하다.


 <U>**만약 각 숫자의 최소 인수가 미리 구해져있다면**</U> 소수들을 하나하나 확인할 것 없이 단계적으로 나눠서 소인수 분해를 할 수 있다.

 ```python
N = int(input())
factor = [0]*N

for i in range(2,N):
    # 소수를 구하는 부분
    if factor[i] == 0:
        factor[i] = i
    # 최소 인수를 구하는 부분
    # 자연수 i의 최소인수보다 작은 j에 대해서
    # i*j의 최소인수는 j가 된다.
    for j in prime:
        # 배열 크기 문제로 인한 조건문
        if i*j>=N:  
            break
        factor[i*j] = j
        if i%j == 0:
            break

print(prime)
print(factor)
 ```

factor 배열의 각 칸은 i 반복문에서 한 번, j 반복문에서 한 번 총 2번만 방문하게 된다. 따라서 <U>**시간 복잡도는 O(N)**</U>이다. factor[i] == i일 때 소수이므로 소수 목록도 쉽게 구할 수 있다. (또는 factor[i] == 0 조건에서 소수 리스트에 추가하는 코드를 넣어도 된다.)
기존 에라토스테네스의 체에서는 소인수의 개수만큼 방문하는 것과 대비된다.

#### 연습 문제
`문제1) 16563. 어려운 소인수분해 https://www.acmicpc.net/problem/16563`


## 1.4 소수를 마치면서

이번 챕터에서는 소수 목록을 구하는 알고리즘, 소수 판별과 소인수 분해에 대해 각각 단일 작업에 대한 알고리즘과 반복 작업에 대한 알고리즘 다루었다.

단일 작업의 경우 반복 작업의 특수 케이스라고 볼 수 있다. 조건이 더 많다는 것은 추가할 수 있는 최적화 요소가 늘어난다는 뜻이다. 비슷한 유형의 문제를 보더라도 기존 문제와의 차이점을 파악하면 더 효율적인 코드를 작성할 수 있다.




# 2. 최대 공약수
## 2.1 최대 공약수를 구하는 방법

### 2.1.1 최대 공약수와 최소 공배수

> **Definition**
> 
> 두 수의 최대 공약수는 공약수 중 가장 큰 것을 말한다.
> 두 수의 최소 공배수는 공배수 중 가장 작은 것을 말한다.

정의만 놓고 보았을 때, 최대 공약수 또는 최소 공배수를 구하기 위해서는 두 수의 약수를 모두 구해놓고 찾아야하는 것으로 보인다.

> **Theorem**
>
> 두 정수 a,b의 최대 공약수를 gcd(a,b), 최소 공배수를 lcm(a,b)로 표현하자.
> 
> lcm(a,b) = a*b/gcd(a,b)이다.

두 수를 최대 공약수로 나누면 서로소가 되므로 우변의 결과가 최소 공배수임을 알 수 있다.


중학교에서는 소인수분해를 통해 약수를 구하지 않고도 최대 공약수를 찾는 법을 배운다.
이전 챕터에서 배운 내용을 활용하면 O(N)의 복잡도로 최대 공약수를 구할 수 있을 것이다. 


### 2.1.2 최대 공약수를 구하는 방법
최대 공약수와 최소 공배수를 계산하는 방법을 알아보자.



하지만 이번 챕터의 내용을 배우고나면 기존의 방법이 복잡하고 비효율적으로 느껴질 것이다.

> **Theorem**
>
> 두 정수 a,b의 최대 공약수를 gcd(a,b)로 표현하자.
> 
> gcd(a,b) = gcd(a, b-a)이다.

증명)<br>
gcd(a,b)가 a, b-a의 **1)공약수**임을 보이고, **2)모든 공약수의 배수**임을 보이면 된다.

1) gcd(a,b) = d라고 하자. 그럼 적당한 정수 a', b'가 존재하여서 a=a'd, b=b'd를 만족한다.
   
   b-a = (b'-a')d 이므로 d는 a, b-a의 공약수이다.
2) d'를 a, b-a의 공약수라고 하자. 
   
   그럼 b = (b-a)+a이므로 d'의 배수이다.

   따라서 d'는 a, b의 공약수이고, d는 최대공약수이므로 d는 d'의 배수이다.

<U>**이는 처음에 주어진 두 수를 더하거나 빼는 작업을 반복하면 모든 d의 배수를 만들 수 있음을 보여준다.**</U>

> **Corollary**
>
> 주어진 두 자연수에서 큰 값에서 작은 값을 빼는 작업을 반복하였을 때,
> 
> 마지막으로 나오는 양수가 두 수의 최대 공약수가 된다.
> 이렇게 최대공약수를 구하는 방법을 유클리드 호제법이라고 한다.

만약 7과 2에 대해서 유클리드 호제법을 적용한다면 (2,7) -> (2,5) -> (2,3) -> (2,1) -> (0,1) 순서로 값이 변하게 되고, 마지막으로 나오는 양수인 1이 최대 공약수가 된다.

7에서 2를 빼는 과정이 총 3번 진행되는데 이를 나머지 연산으로 대체하면 한 번에 처리된다. 나머지 연산을 사용할 경우 시간 복잡도는 O(N)에서 O(logN)으로 줄어들게 된다.

> **예제**
>
> 주어진 두 숫자의 최대 공약수를 유클리드 호제법을 통해 구해보자.
> 
> 예제 풀이
> ```python
> a, b = map(int,input().split())
> while a:
>     a, b = b%a, a
> print(b)
> ```

매우 간단하면서도 굉장히 빠른 코드임을 알 수 있다.

#### 연습 문제
`문제1) 2609. 최대공약수와 최소공배수 https://www.acmicpc.net/problem/2609`<br>
`문제2) 1850. 최대공약수 https://www.acmicpc.net/problem/1850`<br>
`문제3) 9613. GCD합 https://www.acmicpc.net/problem/9613`<br>
`문제4) 2916. 자와 각도기 https://www.acmicpc.net/problem/2916`

## 2.2 서로소

### 2.2.1 서로소의 개수

> **Definition**
> 
> 정수 a,b에 대하여 gcd(a,b) = 1일 때, a와 b를 서로소라고 한다.

앞서 최대공약수를 구하는 방법을 배웠기에, 서로소인지 판별하는 것은 쉽게 할 수 있다. 이번 챕터에서는 숫자 N이 주어졌을 때, N 이하의 서로소의 개수를 구하는 방법을 알아보자.

> **Definition**
>
> 오일러 피(φ) 함수는 서로소의 개수를 나타내는 함수이다.
> n 이하의 자연수 중 n과 서로소인 수의 개수를 φ(n)로 나타낸다.

아마도 이 문서 내에서는 가장 낯선 표현일 것이라 생각되지만, 정의인만큼 '그냥 그렇게 표현하는구나'하고 넘어가면 된다.

그래서 도대체 φ(n)을 어떻게 구하는지 궁금할 수도 있다. 이름만 붙고 계산법은 없는 함수도 많지만, 다행히 오일러 피 함수는 계산하는 방법이 있다.

> **Theorem**
>
> n의 소인수를 p1, p2 ... pi라고 하자
> 
> φ(n) = ((p1-1)/p1)((p2-1)/p2)....((pi-1)/pi)이다.

여기서는 직관적인 이해를 돕기 위해 러프한 증명을 제시한다. 
1. 서로 다른 두 소수 p1, p2에 대해서 임의의 숫자가 p1의 배수일 확률과 p2의 배수일 확률은 독립이다.
2. 임의의 수가 p의 배수일 확률은 1/p이다.
3. 위의 두 조건에 따라서 ((p1-1)/p1)((p2-1)/p2)....((pi-1)/pi)는 임의의 수가 n의 소인수의 배수가 아닐 확률이 된다.
4. n((p1-1)/p1)((p2-1)/p2)....((pi-1)/pi)은 n 이하의 수 중에서 n의 소인수의 배수가 아닌 경우의 수 = 서로소의 개수가 된다.

> **예제**
>
> 자연수 N을 입력 받은 다음, 1~N 중 N과 서로소인 수의 개수를 구해보자.
> 
> 예제 풀이
> ```python
> N = int(input())
> 
> ans = N
> for i in range(2,int(N**0.5)+1):
>     if N%i == 0:
>         while N%i == 0:
>             N//=i
>         ans = ans*(i-1)//i
>         # ans *= (i-1)/i의 경우 결과가 달라질 수 있으므로 주의
> print(ans)
> ```



#### 연습 문제
`문제1) 4355. 서로소 https://www.acmicpc.net/problem/4355`<br>
`문제2) 1750. 서로소의 개수 https://www.acmicpc.net/problem/1750`<br>
`문제3) 11689. GCD(n,k) = 1 https://www.acmicpc.net/problem/11689`<br>
`문제4) 23832. 서로소 그래프 https://www.acmicpc.net/problem/23832`

## 2.3 서로소를 마치면서
이번에는 서로소 판별과 개수를 세기 위해서 유클리드 호제법과 오일러 피 함수를 다루었다. 정규 교육과정만으론 처음 접하고 낯선 내용이기에 엄밀하고 정확한 설명보다는 직관적인 설명에 초점을 맞추어보았다. 수학에 초점을 맞춘다면 정수론 교재를 찾아보는 것이 좋겠지만, 적당한 수준의 알고리즘 문제를 푸는 것이 목표라면 이 정도로도 충분하지 않을까 한다.
